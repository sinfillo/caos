# garbage collector
## Условие задачи
Напишите `mark-and-sweep garbage collector` (сборщик мусора), который находит динамически выделенные области памяти, которые более не достижимы, и освобождает их.

Будем называть аллокацией область памяти, полученную в результате вызова `malloc`. Для каждой аллокации будем хранить такие сведения:
```
typedef void (*finalizer_t)(void *ptr, size_t size);

struct allocation {
    void *ptr; // указатель на область памяти
    size_t size; // размер
    finalizer_t finalizer; // функция, которую следует вызвать перед free
    bool alive; // достижимость
};
```
Указатель `ptr` считается указателем на аллокацию A, если содержит адрес любого байта внутри аллокации или байта сразу после аллокации:
```
bool points_to(void *ptr, struct allocation *A) {
    uintptr_t uptr = (uintptr_t)ptr, aptr = (uintptr_t)A->ptr;
    return (uptr >= aptr) && (uptr - aptr <= A->size);
}
```
Аллокация считается достижимой, если указатель на неё есть в стеке либо в другой достижимой аллокации. Учитываются только правильно выровненные указатели (хранящиеся в памяти по адресам, кратным `alignof(void *)`).

Программа, которая использует сборщик мусора, обязана в функции `main` вызвать `gc_init` с параметром `argv`. Известно, что массив аргументов командной строки лежит внизу стека (по адресу, большему, чем адреса любых автоматических переменных), так что `argv` можно использовать как указатель на дно стека.

Функция `gc_malloc` вызывает `malloc` с переданным ей параметром `size` и в случае успешной аллокации (когда `malloc` вернул не `NULL`) записывает сведения об этой аллокации в свои структуры данных.

Функция `gc_collect_impl` работает следующим образом:

* Помечает все известные ей аллокации как недостижимые.

* Проходит по стеку от `stack_top` (указатель на верхушку стека) до `stack_bottom` (указатель на дно стека) и пытается интерпретировать каждые `sizeof(void *)` байт из стека как указатель. Если это указатель на некоторую известную аллокацию A, то она помечается как достижимая.
Таким же образом проходит по всем достижимым аллокациям, находя в них указатели и помечая достижимые аллокации.

* Для каждой недостижимой аллокации A вызывает `A.finalizer(A.ptr, A.size)` (если `finalizer` не `NULL`) и `free(A.ptr)`, а затем удаляет сведения об аллокации. Недостижимые аллокации можно удалять в любом порядке.

`gc_collect_impl` будет вызываться с помощью ассемблерной обёртки [`gc_collect`](wrapper.S), которая сохраняет в стек значения `callee-saved` регистров и передаёт корректный указатель на верхушку стека `stack_top`. Таким образом, искать указатели в регистрах не придётся.

 