# func-poliz-1
## Условие задачи

Напишите компилятор выражений в польской записи в "шитый" код, то есть в специальное внутреннее представление, удобное для исполнения, как описано далее.

Польская запись передается на вход в виде строки, в которой элементы польской записи отделяются друг от друга пробельными символами. Обозначим стек вычислений польской записи через `S`. На стеке вычислений хранятся 32-битные знаковые целые числа. Элемент `S[0]` — это верхушка стека, `S[1]` — это следующий после верхушки элемент на стеке. В польской записи поддерживаются следующие элементы:

| Command   | Описание                                   | 
| --------- | ------------------------------------------ | 
| `NUM`     | `NUM` — это 32-битное целое число, перед которым допускается необязательные знаки "плюс" или "минус". значение числа помещается в стек.|
| `+`       | Вычислить `S[1] + S[0]`. Оба значения удаляются из стека, результат операции помещается в стек.|
| `-`       | Вычислить `S[1] - S[0]`. Оба значения удаляются из стека, результат операции помещается в стек.|
| `*`       | Вычислить `S[1] * S[0]`. Оба значения удаляются из стека, результат операции помещается в стек.|
| `#`       | Вычислить `-S[0]`.  Аргумент операции удаляется из стека, результат операции помещается в стек.|
| `r`       | Считать со стандартного потока ввода 32-битное знаковое целое значение в десятичной записи, результат операции помещается в стек.|
| `w`       | Вывести на стандартный поток вывода `S[0]`. Аргумент удаляется из стека.|
| `n`       | Вывести на стандартный поток вывода символ `\n`.|
| `;`       | Удалить элемент из верхушки стека.|
| `dNUM`    | Поместить копию элемента `S[NUM]` на верхушку стека. Если `NUM` не указан, подразумевается значение индекса `0`. Таким образом команда `d` копирует элемент на верхушке стека, как и команда `d0`. Команда `d1` заносит на верхушку стека значение `S[1]`, где индекс берется до выполнения операции занесения в стек. Индекс `NUM` всегда неотрицательный. Команда должна выполняться за амортизированное `O(1)`.|
| `sNUM`    | Обменять местами `S[NUM]` и `S[0]`. Если `NUM` не указан, подразумевается значение индекса `1`. Таким образом команда `s` меняет местами `S[1]` и `S[0]`, как и команда `s1`. Команда `s0` не делает ничего (даже если стек пуст). Индекс `NUM` всегда неотрицательный. Команда должна выполняться за `O(1)`.|

Предопределены следующие типы данных:
```
// opaque structure for poliz calculation state
struct PolizState;

// poliz operation handler
typedef int (*poliz_func_t)(struct PolizState *state, int iextra);

struct PolizItem
{
    poliz_func_t handler;
    int iextra;
};

// runtime errors
enum
{
    PE_OK,  // no error
    PE_STACK_UNDERFLOW, // not enough elements on stack
    PE_INVALID_INDEX, // s or d operations refer to invalid index
    PE_DIVISION_BY_ZERO,
    PE_INT_OVERFLOW,
    PE_READ_FAILED, // read from stdin failed to convert integer for any reason
    PE_OUT_OF_MEMORY,
};

struct PolizItem *poliz_compile(const char *str);

struct PolizState *poliz_new_state(void);
void poliz_free_state(struct PolizState *state);
int poliz_last_error(struct PolizState *state);
```
Функция компиляции должна иметь следующий прототип:
```
struct PolizItem *poliz_compile(const char *str);
```
Функция компиляции возвращает массив элементов польской записи. Последний элемент массива содержит указатель `handler` равный `NULL`. Массив должен выделяться в динамической памяти.

Если дана строка `str`, то вычисление значения выполняется следующим образом:
```
struct PolizItem *items = poliz_compile(str);
struct PolizState *state = poliz_new_state();
for (int i = 0; items[i].handler != NULL; ++i) {
    int err = items[i].handler(state, items[i].iextra);
    if (err < 0) {
        fprintf(stderr, "error: %d\n", -err);
        break;
    } else if (err > 0) {
        abort();  // хендлеры должны возвращать код ошибки со знаком '-'
    }
}
poliz_free_state(state);
free(items);
```
Ваша задача: написать функции `poliz_compile`, `poliz_new_state`, `poliz_free_state`, `poliz_last_error` и функции-обработчики команд польской записи. Вам будет доступен заголовочный файл [`poliz.h`](poliz.h), который вы можете включать директивой `#include`.

Функция `poliz_last_error` возвращает неотрицательный код последней ошибки при выполнении польской записи. Если в процессе выполнения произошла ошибка, но выполнение не было прервано (например, если из примера выше убрать `break`), то все последующие после ошибки команды не должны ничего делать, то есть в начале каждого обработчика команды должна находиться проверка:
```
// проверяем была ли ошибка ранее
if (state->err) return -state->err;
```

Можете предполагать, что польская запись корректна, за исключением возможных ошибок времени выполнения. То есть, польская запись может содержать ошибку деления на константу 0, но выявлять ее при компиляции, как и выявлять антипереполнение и другие ошибки времени выполнения не нужно.



